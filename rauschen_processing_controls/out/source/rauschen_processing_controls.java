/* autogenerated by Processing revision 1295 on 2025-03-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import oscP5.*;
import netP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class rauschen_processing_controls extends PApplet {




OscP5 oscP5;
NetAddress mainSketchLocation;

int width = 700;
int height = 200;

// init some predetermined colors so that they are easily differentiated
int[] colors = new int[] {
	0xFFFF0000, 
	0xFF00FF00,
	0xFF0000FF, 
	0xFFDC143C, 
	0xFF228B22, 
	0xFF1E90FF, 
	0xFFBA55D3, 
	0xFF3CB371, 
	0xFF7B68EE, 
	0xFFC71585, 
	0xFF00FA9A, 
	0xFF0000CD,
	0xFFFF4500,  // OrangeRed
	0xFF32CD32,  // LimeGreen
	0xFF4169E1,  // RoyalBlue
	0xFFFFD700,  // Gold
	0xFF8A2BE2,  // BlueViolet
	0xFF20B2AA,  // LightSeaGreen
	0xFFFF69B4,  // HotPink
	0xFF8B0000,  // DarkRed
	0xFF556B2F,  // DarkOliveGreen
	0xFF00CED1,  // DarkTurquoise
	0xFFDAA520,  // GoldenRod
	0xFF9400D3,  // DarkViolet
	0xFF4682B4,  // SteelBlue
	0xFFD2691E,  // Chocolate
	0xFFB22222,  // FireBrick
	0xFF708090,  // SlateGray
	0xFF9932CC,  // DarkOrchid
	0xFFFF6347,  // Tomato
	0xFF48D1CC,  // MediumTurquoise
	0xFF7FFF00   // Chartreuse
};

// init ArrayList of graphs
ArrayList<Graph> graphs = new ArrayList<Graph>();

public void settings() {
	size(width, height);
}

public void setup() {
	// determine window location on screen
	surface.setLocation(1050, 60);

	// init OSC
	oscP5 = new OscP5(this, 12000); // local port for this sketch
	mainSketchLocation = new NetAddress("127.0.0.1", 9000); // receiver on port 12000
}

public void draw() {
	background(0);
	strokeWeight(2);

	// display all graphs
	for (int i = 0; i < graphs.size(); i++) {
		// get and display graph
		Graph g = graphs.get(i);
		g.display();
	}
}

// called when new OSC message is received
public void oscEvent(OscMessage msg) {
	// Check if it's the message with our noise values
	if (msg.checkAddrPattern("/noises")) {
		// Get the typetag to know how many values were sent
		String typetag = msg.typetag();
		int numValues = typetag.length() - 1; // Subtract 1 for the comma at the beginning

		// ensure there is the right number of graphs
		while (graphs.size() < numValues) {
			graphs.add(new Graph(colors[graphs.size() % colors.length]));
		}
		
		// if there are too many graphs, remove extras
		while (graphs.size() > numValues) {
			graphs.remove(graphs.size() - 1);
		}
		
		// add received values directly to graphs
		for (int i = 0; i < numValues; i++) {
			float value = msg.get(i).floatValue();
			graphs.get(i).addPoint(value);
		}
	}	
}
// a Graph is a series of values on the Y axis that is displayed in a certain color
class Graph {
	ArrayList<Float> points;
	int col;

	// constructor
	public Graph(int c) {
		points = new ArrayList<Float>();
		col = c;
		init();
	}

	// add a point to the graph
	public void addPoint(float point) {
		// if the graph is wider than the window, remove the first point
		if (points.size() > width) {
			points.remove(0);
		}
		// add a new point
		points.add(point);
	}

	// add empty points to the graph on setup
	public void init() {
		for (int i = 0; i < width; i++) {
			points.add(0.0f);
		}
	}

	// display points from graph // CURRENTLY UNUSED BECAUSE VERTICES ONLY DISPLAY WHEN DONE IN GRAPHS DIRECTLY
	public void display() {
		stroke(col);
		beginShape(LINES);
			for (int x = 0; x < points.size(); x++) {
				// draw the points
				Float y = points.get(x);
				if (y != null) {
					vertex(x, map(y, 0, 1, height - 20, 20));
				}
			}
		endShape();
	}
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "rauschen_processing_controls" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
